# è¯­ä¹‰å»ºå›¾ä¸åŠ¨æ€æ ‡æ³¨æœºåˆ¶è¯´æ˜

## ğŸ“‹ ç›®å½•

1. [å»ºå›¾æ¶æ„](#å»ºå›¾æ¶æ„)
2. [åŠ¨æ€æ¸²æŸ“æœºåˆ¶](#åŠ¨æ€æ¸²æŸ“æœºåˆ¶)
3. [å­ä»»åŠ¡åˆ‡æ¢æµç¨‹](#å­ä»»åŠ¡åˆ‡æ¢æµç¨‹)
4. [è½¨è¿¹ç®¡ç†](#è½¨è¿¹ç®¡ç†)
5. [Landmarkæ ‡æ³¨](#landmarkæ ‡æ³¨)

---

## ğŸ—ï¸ å»ºå›¾æ¶æ„

### åœ°å›¾æ•°æ®ç»“æ„

```python
# mapper.py
full_map: np.ndarray  # [4+N, H, W]
    # é€šé“0: éšœç¢ç‰© (obstacles)
    # é€šé“1: å·²æ¢ç´¢ (explored)
    # é€šé“2: å½“å‰è§‚å¯Ÿ (current obs)
    # é€šé“3: å·²è®¿é—® (visited)
    # é€šé“4+: è¯­ä¹‰ç±»åˆ« (semantic classes)

trajectory_points: List[Tuple[int, int]]  # è½¨è¿¹ç‚¹åˆ—è¡¨
landmark_classes: List[str]  # å½“å‰è¦æ ‡æ³¨çš„landmark
```

### æ¸²æŸ“å±‚æ¬¡

```
åº•å›¾ (full_map)
    â†“
è¯­ä¹‰åœ°å›¾ (sem_map_vis)
    â†“
æ—‹è½¬è°ƒæ•´ (global_map_rotated)
    â†“
æ˜¾ç¤ºå‰¯æœ¬ (global_map_with_trajectory)  â† åœ¨è¿™é‡ŒåŠ¨æ€ç»˜åˆ¶
    â”œâ”€â”€ æ©™è‰²è½¨è¿¹çº¿ (åŠ¨æ€)
    â”œâ”€â”€ çº¢è‰²ç®­å¤´ (åŠ¨æ€)
    â””â”€â”€ ç´«è‰²landmarkåœ†çƒ (åŠ¨æ€)
```

**å…³é”®ç‚¹**ï¼š
- âœ… åº•å›¾ (full_map) åªåŒ…å«è¯­ä¹‰ä¿¡æ¯ï¼Œä¸å«è½¨è¿¹å’Œlandmark
- âœ… è½¨è¿¹å’Œlandmarkåœ¨æ¸²æŸ“æ—¶åŠ¨æ€ç»˜åˆ¶åœ¨æ˜¾ç¤ºå‰¯æœ¬ä¸Š
- âœ… å¯ä»¥éšæ—¶æ¸…ç©º/æ›¿æ¢ï¼Œä¸å½±å“åº•å›¾

---

## ğŸ¨ åŠ¨æ€æ¸²æŸ“æœºåˆ¶

### 1. è½¨è¿¹åŠ¨æ€ç»˜åˆ¶

**ä»£ç ä½ç½®**: `visualizer.py` Line 186-202

```python
# æ­¥éª¤1: åˆ›å»ºæ˜¾ç¤ºå‰¯æœ¬
global_map_with_trajectory = global_map_rotated.copy()

# æ­¥éª¤2: åŠ¨æ€ç»˜åˆ¶è½¨è¿¹ï¼ˆä¸å†™å…¥åº•å›¾ï¼‰
if len(trajectory_points) >= 2:
    rotated_trajectory = []
    for x, y in trajectory_points:
        # åæ ‡è½¬æ¢
        display_x = y * 480 / w
        display_y = (h - 1 - x) * 480 / h
        point = np.array([display_x, display_y, 1])
        rotated_point = rotation_matrix @ point
        rotated_trajectory.append([int(round(rotated_point[0])), 
                                   int(round(rotated_point[1]))])
    
    # åœ¨æ˜¾ç¤ºå‰¯æœ¬ä¸Šç»˜åˆ¶æ©™è‰²è½¨è¿¹
    cv2.polylines(global_map_with_trajectory, [trajectory_array], 
                  isClosed=False, color=(0, 165, 255), 
                  thickness=2, lineType=cv2.LINE_8)
```

**ç‰¹ç‚¹**ï¼š
- âœ… ä¸ä¿®æ”¹åº•å›¾ `global_map_rotated`
- âœ… åªåœ¨æ˜¾ç¤ºå‰¯æœ¬ä¸Šç»˜åˆ¶
- âœ… æ¸…ç©º `trajectory_points` åˆ—è¡¨å³å¯ç§»é™¤è½¨è¿¹

### 2. LandmarkåŠ¨æ€æ ‡æ³¨

**ä»£ç ä½ç½®**: `visualizer.py` Line 213-229

```python
# æ­¥éª¤1: ä»full_mapæå–landmarkä½ç½®
landmarks = self._extract_landmarks(
    full_map, detected_classes, landmark_classes,
    min_total_pixels, min_area_threshold
)

# æ­¥éª¤2: åŠ¨æ€ç»˜åˆ¶landmarkï¼ˆä¸å†™å…¥åº•å›¾ï¼‰
for marker_x, marker_y, cls_name in landmarks:
    # åæ ‡è½¬æ¢
    display_x = marker_x * 480 / w
    display_y = (h - 1 - marker_y) * 480 / h
    point = np.array([display_x, display_y, 1])
    rotated_point = rotation_matrix @ point
    
    # åœ¨æ˜¾ç¤ºå‰¯æœ¬ä¸Šç»˜åˆ¶ç´«è‰²åœ†çƒ
    cv2.circle(global_map_with_trajectory, 
              (int(rotated_point[0]), int(rotated_point[1])), 
              landmark_marker_radius, landmark_marker_color, -1)
```

**ç‰¹ç‚¹**ï¼š
- âœ… åŸºäº `landmark_classes` åŠ¨æ€è¿‡æ»¤
- âœ… æ›´æ–° `landmark_classes` å³å¯åˆ‡æ¢æ ‡æ³¨
- âœ… ä¸ä¿®æ”¹åº•å›¾çš„è¯­ä¹‰ä¿¡æ¯

---

## ğŸ”„ å­ä»»åŠ¡åˆ‡æ¢æµç¨‹

### å®Œæ•´æµç¨‹

```
å­ä»»åŠ¡æ‰§è¡Œä¸­...
    â†“
360Â° ç¯è§†å»ºå›¾
    â†“
LLMéªŒè¯: is_completed = true?
    â†“ YES
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å­ä»»åŠ¡å®Œæˆ - æ¸…ç†ä¸æ›´æ–°          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. æ¸…ç©ºè½¨è¿¹                      â”‚
â”‚    mapper.clear_trajectory()     â”‚
â”‚                                  â”‚
â”‚ 2. æ›´æ–°Landmark                  â”‚
â”‚    landmark_classes = [new]      â”‚
â”‚                                  â”‚
â”‚ 3. å¼€å§‹æ–°å­ä»»åŠ¡                  â”‚
â”‚    subtask_count += 1            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
æ–°å­ä»»åŠ¡å¼€å§‹
    â†“
è®°å½•æ–°è½¨è¿¹ç‚¹
æ˜¾ç¤ºæ–°landmark
```

### ä»£ç å®ç°

**ä½ç½®**: `vlm_navigation_controller.py` Line 450-480

```python
def verify_and_replan(self) -> Tuple[bool, Optional[Dict]]:
    # ... 360Â° ç¯è§†å»ºå›¾ ...
    
    # LLMéªŒè¯
    response, is_completed = self.planner.verify_and_replan(...)
    
    if is_completed:
        print(f"\nâœ… å­ä»»åŠ¡ #{self.subtask_count} å®Œæˆ!")
        
        if response.get('is_final_subtask', False):
            return True, response
        
        # â­ å…³é”®æ­¥éª¤1: æ¸…ç©ºä¸Šä¸€ä¸ªå­ä»»åŠ¡çš„è½¨è¿¹
        print("  ğŸ§¹ æ¸…ç©ºä¸Šä¸€å­ä»»åŠ¡è½¨è¿¹...")
        self.mapper.clear_trajectory()
        
        # æ›´æ–°åˆ°æ–°å­ä»»åŠ¡
        self.subtask_count += 1
        self.current_subtask = response
        
        # â­ å…³é”®æ­¥éª¤2: æ›´æ–°landmarkï¼ˆè‡ªåŠ¨æ›¿æ¢ä¸Šä¸€ä¸ªï¼‰
        subtask_landmark = response.get('subtask_landmark', None)
        if subtask_landmark:
            if subtask_landmark in self.mapping_classes:
                self.landmark_classes = [subtask_landmark]
                self.target_landmark = subtask_landmark
                print(f"  ğŸ¯ æ–°ç›®æ ‡Landmark: {self.target_landmark}")
                print(f"  ğŸ“ å·²æ›´æ–°landmark_classes: {self.landmark_classes} (æ›¿æ¢ä¸Šä¸€å­ä»»åŠ¡)")
```

---

## ğŸ›¤ï¸ è½¨è¿¹ç®¡ç†

### è½¨è¿¹è®°å½•

**ä½ç½®**: `mapper.py` Line 199-216

```python
def update_trajectory(self, full_pose: np.ndarray):
    """
    æ›´æ–°è½¨è¿¹åæ ‡åˆ—è¡¨ï¼ˆè®°å½•ä½ç½®ç‚¹ï¼Œç¨åç»˜åˆ¶å¹³æ»‘æ›²çº¿ï¼‰
    
    Args:
        full_pose: [3] (x, y, orientation) å½“å‰ä½å§¿ï¼ˆç±³ï¼‰
    """
    if not self.enable_trajectory:
        return
    
    # è½¬æ¢ä½ç½®åˆ°åƒç´ åæ ‡
    position = full_pose[:2] * 100 / self.resolution
    y = int(np.clip(position[0], 0, self.map_shape[0] - 1))
    x = int(np.clip(position[1], 0, self.map_shape[1] - 1))
    
    # æ·»åŠ åˆ°è½¨è¿¹ç‚¹åˆ—è¡¨ï¼ˆé¿å…é‡å¤ï¼‰
    if len(self.trajectory_points) == 0 or self.trajectory_points[-1] != (x, y):
        self.trajectory_points.append((x, y))
```

### è½¨è¿¹æ¸…ç©º

**ä½ç½®**: `mapper.py` Line 224-237

```python
def clear_trajectory(self):
    """
    æ¸…ç©ºå½“å‰è½¨è¿¹
    
    ä½¿ç”¨åœºæ™¯ï¼š
    - å­ä»»åŠ¡å®Œæˆæ—¶ï¼šæ¸…ç©ºä¸Šä¸€å­ä»»åŠ¡çš„è½¨è¿¹ï¼Œå¼€å§‹è®°å½•æ–°å­ä»»åŠ¡è½¨è¿¹
    - æ¯ä¸ªå­ä»»åŠ¡éƒ½æœ‰ç‹¬ç«‹çš„è½¨è¿¹æ˜¾ç¤ºï¼Œä¸ä¼šç´¯ç§¯
    
    æ³¨æ„ï¼š
    - è½¨è¿¹æ˜¯åŠ¨æ€ç»˜åˆ¶åœ¨åœ°å›¾ä¸Šçš„ï¼Œä¸ä¼šå†™å…¥åº•å›¾
    - landmarkæ ‡æ³¨åŒæ ·æ˜¯åŠ¨æ€ç»˜åˆ¶ï¼Œæ›´æ–°landmark_classeså³å¯æ›¿æ¢
    """
    self.trajectory_points = []
```

### è½¨è¿¹å¼€å…³

```python
# å¯ç”¨/ç¦ç”¨è½¨è¿¹è®°å½•
mapper.toggle_trajectory()  # åˆ‡æ¢å¼€å…³

# æ‰‹åŠ¨æ¸…ç©ºè½¨è¿¹
mapper.clear_trajectory()  # æ¸…ç©ºåˆ—è¡¨
```

---

## ğŸ¯ Landmarkæ ‡æ³¨

### Landmarkæå–é€»è¾‘

**ä½ç½®**: `visualizer.py` Line 683-730

```python
def _extract_landmarks(self,
                      full_map: np.ndarray,
                      detected_classes: List[str],
                      landmark_classes: List[str],
                      min_total_pixels: int,
                      min_area_threshold: int) -> List[Tuple[int, int, str]]:
    """
    ä»è¯­ä¹‰åœ°å›¾ä¸­æå–landmarkä½ç½®
    
    è¿‡æ»¤æ¡ä»¶ï¼š
    1. ç±»åˆ«å¿…é¡»åœ¨ landmark_classes ä¸­
    2. æ€»åƒç´ æ•° >= min_total_pixels
    3. è¿é€šåŸŸé¢ç§¯ >= min_area_threshold
    4. é€‰æ‹©æœ€å¤§è¿é€šåŸŸä½œä¸ºä»£è¡¨
    
    Returns:
        [(x, y, class_name), ...] landmarkä½ç½®åˆ—è¡¨
    """
    landmarks = []
    
    for cls_idx, cls_name in enumerate(detected_classes):
        # â­ å…³é”®è¿‡æ»¤ï¼šåªå¤„ç† landmark_classes ä¸­çš„ç±»åˆ«
        if cls_name not in landmark_classes:
            continue
        
        # è·å–è¯­ä¹‰mask
        semantic_channel_idx = 4 + cls_idx
        if semantic_channel_idx >= full_map.shape[0]:
            continue
        
        cls_mask = full_map[semantic_channel_idx, ...] > 0.5
        
        # æ£€æŸ¥æ€»åƒç´ æ•°
        total_pixels = int(cls_mask.sum())
        if total_pixels < min_total_pixels:
            continue
        
        # è¿é€šåŸŸåˆ†æ
        labeled_mask = label(cls_mask, connectivity=2)
        regions = regionprops(labeled_mask)
        
        if len(regions) == 0:
            continue
        
        # é€‰æ‹©æœ€å¤§è¿é€šåŸŸ
        largest_region = max(regions, key=lambda r: r.area)
        
        if largest_region.area < min_area_threshold:
            continue
        
        # ä½¿ç”¨è´¨å¿ƒä½œä¸ºlandmarkä½ç½®
        cy, cx = largest_region.centroid
        landmarks.append((int(cx), int(cy), cls_name))
    
    return landmarks
```

### Landmarkæ›´æ–°æœºåˆ¶

```python
# å­ä»»åŠ¡1: å¯¼èˆªåˆ°cabinet
landmark_classes = ["cabinet"]  # åªæ˜¾ç¤ºcabinetçš„ç´«è‰²åœ†çƒ
    â†“
# å­ä»»åŠ¡2: å¯¼èˆªåˆ°bed
landmark_classes = ["bed"]      # è‡ªåŠ¨æ›¿æ¢ï¼Œåªæ˜¾ç¤ºbedçš„ç´«è‰²åœ†çƒ
    â†“
# å­ä»»åŠ¡3: å¯¼èˆªåˆ°door
landmark_classes = ["door"]     # è‡ªåŠ¨æ›¿æ¢ï¼Œåªæ˜¾ç¤ºdoorçš„ç´«è‰²åœ†çƒ
```

**å…³é”®ç‚¹**ï¼š
- âœ… æ¯æ¬¡æ›´æ–° `landmark_classes` ä¼š**è‡ªåŠ¨æ›¿æ¢**ä¸Šä¸€ä¸ª
- âœ… ä¸éœ€è¦æ‰‹åŠ¨æ¸…é™¤ï¼Œç³»ç»Ÿè‡ªåŠ¨è¿‡æ»¤
- âœ… åº•å›¾çš„è¯­ä¹‰ä¿¡æ¯ä¿æŒä¸å˜

---

## ğŸ¬ å®Œæ•´ç¤ºä¾‹

### åœºæ™¯ï¼šå¯¼èˆªåˆ°bedroomçš„bed

```python
# ========== å­ä»»åŠ¡1: å‰å¾€èµ°å»Šå°½å¤´ ==========
# LLMè¾“å‡º
{
    "subtask_landmark": "door",
    "subtask_destination": "èµ°å»Šå°½å¤´çš„é—¨",
    ...
}

# ç³»ç»ŸçŠ¶æ€
landmark_classes = ["door"]           # åœ°å›¾æ˜¾ç¤ºdoorçš„ç´«è‰²åœ†çƒ
trajectory_points = [(10,20), (15,25), ...]  # è®°å½•è½¨è¿¹
```

**åœ°å›¾æ˜¾ç¤º**ï¼š
- ğŸŸ£ ç´«è‰²åœ†çƒæ ‡æ³¨doorä½ç½®
- ğŸŸ  æ©™è‰²è½¨è¿¹çº¿æ˜¾ç¤ºä»èµ·ç‚¹åˆ°å½“å‰ä½ç½®

```python
# ========== å­ä»»åŠ¡1å®Œæˆï¼Œåˆ‡æ¢åˆ°å­ä»»åŠ¡2 ==========

# ç³»ç»Ÿæ“ä½œ
mapper.clear_trajectory()            # æ¸…ç©ºè½¨è¿¹ âœ…
landmark_classes = ["bed"]           # æ›¿æ¢landmark âœ…
trajectory_points = []               # é‡æ–°å¼€å§‹è®°å½• âœ…

# LLMè¾“å‡º
{
    "subtask_landmark": "bed",
    "subtask_destination": "å§å®¤é‡Œçš„åºŠ",
    ...
}
```

**åœ°å›¾æ˜¾ç¤ºå˜åŒ–**ï¼š
- âŒ doorçš„ç´«è‰²åœ†çƒæ¶ˆå¤±ï¼ˆè¢«bedæ›¿æ¢ï¼‰
- âŒ ä¸Šä¸€ä¸ªå­ä»»åŠ¡çš„æ©™è‰²è½¨è¿¹æ¶ˆå¤±ï¼ˆè¢«æ¸…ç©ºï¼‰
- âœ… æ–°çš„bedç´«è‰²åœ†çƒå‡ºç°
- âœ… æ–°çš„è½¨è¿¹çº¿å¼€å§‹è®°å½•

---

## âœ… æ€»ç»“

### åŠ¨æ€æ¸²æŸ“çš„ä¼˜åŠ¿

1. **çµæ´»æ€§**ï¼š
   - âœ… è½¨è¿¹å’Œlandmarkä¸å†™å…¥åº•å›¾
   - âœ… éšæ—¶æ¸…ç©º/æ›¿æ¢
   - âœ… ä¸å½±å“è¯­ä¹‰å»ºå›¾

2. **å­ä»»åŠ¡éš”ç¦»**ï¼š
   - âœ… æ¯ä¸ªå­ä»»åŠ¡æœ‰ç‹¬ç«‹çš„è½¨è¿¹æ˜¾ç¤º
   - âœ… æ¯ä¸ªå­ä»»åŠ¡åªæ˜¾ç¤ºå½“å‰ç›®æ ‡landmark
   - âœ… åˆ‡æ¢æ—¶è‡ªåŠ¨æ¸…ç†

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - âœ… åº•å›¾ä¸éœ€è¦é‡æ–°ç”Ÿæˆ
   - âœ… åªéœ€æ›´æ–°æ˜¾ç¤ºå‰¯æœ¬
   - âœ… æ¸²æŸ“é€Ÿåº¦å¿«

### å…³é”®API

```python
# è½¨è¿¹ç®¡ç†
mapper.update_trajectory(pose)    # è®°å½•ä½ç½®ç‚¹
mapper.clear_trajectory()         # æ¸…ç©ºè½¨è¿¹
mapper.toggle_trajectory()        # åˆ‡æ¢å¼€å…³

# Landmarkç®¡ç†
self.landmark_classes = ["bed"]   # æ›´æ–°è¦æ˜¾ç¤ºçš„landmark
self.target_landmark = "bed"      # è®°å½•å½“å‰ç›®æ ‡

# å­ä»»åŠ¡åˆ‡æ¢
if is_completed:
    mapper.clear_trajectory()     # æ¸…ç©ºè½¨è¿¹ â­
    landmark_classes = [new]      # æ›´æ–°landmark â­
```

---

## ğŸ“ é…ç½®å‚æ•°

```python
# constants.py

# Landmarkæ˜¾ç¤ºé˜ˆå€¼
landmark_min_total_pixels = 1       # æ€»åƒç´ æ•°ï¼ˆ1=ä¸è¿‡æ»¤ï¼‰
landmark_min_area_threshold = 30    # å•ä¸ªè¿é€šåŸŸæœ€å°é¢ç§¯

# æ˜¾ç¤ºæ ·å¼
landmark_marker_color = (128, 0, 128)    # ç´«è‰²(BGR)
landmark_marker_radius = 6               # åœ†çƒåŠå¾„
```

---

**æœ€åæ›´æ–°**: 2025å¹´12æœˆ9æ—¥
